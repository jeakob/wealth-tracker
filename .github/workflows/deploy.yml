name: Deploy Demo to GitHub Pages

on:
  push:
    branches: [ main ]
  workflow_dispatch:

permissions:
  contents: read
  pages: write
  id-token: write

concurrency:
  group: "pages"
  cancel-in-progress: false

jobs:
  deploy:
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json

      - name: Install dependencies
        working-directory: ./frontend
        run: npm ci

      - name: Create browser storage adapter
        working-directory: ./frontend
        run: |
          echo "ðŸ“ Current directory structure:"
          ls -la
          
          # Check if src exists, if not try to find where the source files are
          if [ -d "src" ]; then
            echo "âœ… src/ directory found"
            SRC_DIR="src"
          elif [ -d "app" ]; then
            echo "âœ… app/ directory found (Next.js style)"
            SRC_DIR="app"
          else
            echo "âš ï¸  Creating src/ directory"
            mkdir -p src
            SRC_DIR="src"
          fi
          
          # Create lib directory if it doesn't exist
          mkdir -p "$SRC_DIR/lib"
          
          # Create the browser storage module
          cat > "$SRC_DIR/lib/browserStorage.js" << 'STORAGE_EOF'
          // Auto-generated browser storage adapter for GitHub Pages demo
          
          const STORAGE_PREFIX = 'wealth_tracker_';
          
          const storage = {
            get: (key) => {
              try {
                const item = localStorage.getItem(STORAGE_PREFIX + key);
                return item ? JSON.parse(item) : null;
              } catch (e) {
                console.error('Storage get error:', e);
                return null;
              }
            },
            
            set: (key, value) => {
              try {
                localStorage.setItem(STORAGE_PREFIX + key, JSON.stringify(value));
                return true;
              } catch (e) {
                console.error('Storage set error:', e);
                return false;
              }
            },
            
            remove: (key) => {
              try {
                localStorage.removeItem(STORAGE_PREFIX + key);
                return true;
              } catch (e) {
                console.error('Storage remove error:', e);
                return false;
              }
            },
            
            getAll: (prefix) => {
              const result = {};
              for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key && key.startsWith(STORAGE_PREFIX + prefix)) {
                  const shortKey = key.replace(STORAGE_PREFIX, '');
                  result[shortKey] = storage.get(shortKey.replace(prefix, ''));
                }
              }
              return result;
            }
          };
          
          // Initialize with sample data if empty
          const initSampleData = () => {
            if (!storage.get('initialized')) {
              storage.set('initialized', true);
              storage.set('assets', [
                {
                  id: '1',
                  name: 'Savings Account',
                  type: 'Bank Account',
                  value: 25000,
                  currency: 'USD',
                  icon: 'piggy-bank',
                  createdAt: new Date().toISOString(),
                  updatedAt: new Date().toISOString()
                },
                {
                  id: '2',
                  name: 'Investment Portfolio',
                  type: 'Investments',
                  value: 50000,
                  currency: 'USD',
                  icon: 'trending-up',
                  createdAt: new Date().toISOString(),
                  updatedAt: new Date().toISOString()
                }
              ]);
              storage.set('settings', {
                currency: 'USD',
                theme: 'dark',
                locale: 'en-US'
              });
            }
          };
          
          export const mockAPI = {
            assets: {
              getAll: () => Promise.resolve(storage.get('assets') || []),
              getById: (id) => {
                const assets = storage.get('assets') || [];
                return Promise.resolve(assets.find(a => a.id === id) || null);
              },
              create: (asset) => {
                const assets = storage.get('assets') || [];
                const newAsset = {
                  ...asset,
                  id: Date.now().toString(),
                  createdAt: new Date().toISOString(),
                  updatedAt: new Date().toISOString()
                };
                assets.push(newAsset);
                storage.set('assets', assets);
                return Promise.resolve(newAsset);
              },
              update: (id, updates) => {
                const assets = storage.get('assets') || [];
                const index = assets.findIndex(a => a.id === id);
                if (index >= 0) {
                  assets[index] = { ...assets[index], ...updates, updatedAt: new Date().toISOString() };
                  storage.set('assets', assets);
                  return Promise.resolve(assets[index]);
                }
                return Promise.resolve(null);
              },
              delete: (id) => {
                let assets = storage.get('assets') || [];
                assets = assets.filter(a => a.id !== id);
                storage.set('assets', assets);
                return Promise.resolve({ success: true });
              }
            },
            
            settings: {
              get: () => Promise.resolve(storage.get('settings') || { currency: 'USD', theme: 'dark' }),
              update: (updates) => {
                const current = storage.get('settings') || {};
                const updated = { ...current, ...updates };
                storage.set('settings', updated);
                return Promise.resolve(updated);
              }
            },
            
            history: {
              getAll: () => {
                const assets = storage.get('assets') || [];
                const totalValue = assets.reduce((sum, a) => sum + (a.value || 0), 0);
                // Generate mock history data
                const history = [];
                for (let i = 30; i >= 0; i--) {
                  const date = new Date();
                  date.setDate(date.getDate() - i);
                  history.push({
                    date: date.toISOString(),
                    totalValue: totalValue * (0.9 + Math.random() * 0.2),
                    assetBreakdown: {}
                  });
                }
                return Promise.resolve(history);
              }
            }
          };
          
          // Initialize on load
          if (typeof window !== 'undefined') {
            initSampleData();
          }
          
          export default mockAPI;
          STORAGE_EOF

      - name: Create API interceptor
        working-directory: ./frontend
        run: |
          # Use the same SRC_DIR we found earlier
          if [ -d "src" ]; then
            SRC_DIR="src"
          elif [ -d "app" ]; then
            SRC_DIR="app"
          else
            SRC_DIR="src"
          fi
          
          # Create an interceptor that replaces fetch calls
          cat > "$SRC_DIR/lib/apiInterceptor.js" << 'INTERCEPTOR_EOF'
          import mockAPI from './browserStorage.js';
          
          const originalFetch = window.fetch;
          
          window.fetch = function(...args) {
            const url = args[0];
            const options = args[1] || {};
            
            // Intercept API calls
            if (typeof url === 'string' && url.includes('/api/')) {
              console.log('ðŸ”„ Intercepted API call:', url, options);
              
              // Assets endpoints
              if (url.includes('/api/assets')) {
                if (options.method === 'POST') {
                  return mockAPI.assets.create(JSON.parse(options.body));
                } else if (options.method === 'PUT' || options.method === 'PATCH') {
                  const id = url.split('/').pop();
                  return mockAPI.assets.update(id, JSON.parse(options.body));
                } else if (options.method === 'DELETE') {
                  const id = url.split('/').pop();
                  return mockAPI.assets.delete(id);
                } else {
                  // GET
                  if (url.match(/\/api\/assets\/[^/]+$/)) {
                    const id = url.split('/').pop();
                    return mockAPI.assets.getById(id).then(data => ({
                      ok: true,
                      json: () => Promise.resolve(data)
                    }));
                  }
                  return mockAPI.assets.getAll().then(data => ({
                    ok: true,
                    json: () => Promise.resolve(data)
                  }));
                }
              }
              
              // Settings endpoints
              if (url.includes('/api/settings')) {
                if (options.method === 'PUT' || options.method === 'PATCH' || options.method === 'POST') {
                  return mockAPI.settings.update(JSON.parse(options.body)).then(data => ({
                    ok: true,
                    json: () => Promise.resolve(data)
                  }));
                } else {
                  return mockAPI.settings.get().then(data => ({
                    ok: true,
                    json: () => Promise.resolve(data)
                  }));
                }
              }
              
              // History endpoints
              if (url.includes('/api/history')) {
                return mockAPI.history.getAll().then(data => ({
                  ok: true,
                  json: () => Promise.resolve(data)
                }));
              }
              
              // For axios-style responses, wrap in a Promise
              return Promise.resolve({
                ok: true,
                status: 200,
                json: () => Promise.resolve({ message: 'Intercepted by browser storage' })
              });
            }
            
            // Pass through non-API calls
            return originalFetch.apply(this, args);
          };
          
          console.log('âœ… Browser storage API interceptor loaded');
          INTERCEPTOR_EOF

      - name: Inject interceptor into entry point
        working-directory: ./frontend
        run: |
          echo "ðŸ” Looking for entry file..."
          
          # Determine source directory
          if [ -d "src" ]; then
            SRC_DIR="src"
          elif [ -d "app" ]; then
            SRC_DIR="app"
          else
            SRC_DIR="."
          fi
          
          echo "ðŸ“ Using source directory: $SRC_DIR"
          ls -la "$SRC_DIR/"
          
          # Find the main entry file
          ENTRY_FILE=$(find "$SRC_DIR" -maxdepth 1 \( -name "main.*" -o -name "index.*" -o -name "App.*" \) | head -1)
          
          if [ -z "$ENTRY_FILE" ]; then
            echo "âš ï¸  Could not find entry file, checking subdirectories..."
            ENTRY_FILE=$(find "$SRC_DIR" -maxdepth 2 \( -name "main.*" -o -name "index.*" \) | head -1)
          fi
          
          if [ -z "$ENTRY_FILE" ]; then
            echo "âŒ Could not find entry file. Available files:"
            find "$SRC_DIR" -type f -name "*.jsx" -o -name "*.tsx" -o -name "*.js" -o -name "*.ts"
            echo "âš ï¸  Skipping interceptor injection - will rely on manual API replacement"
          else
            echo "ðŸ“ Injecting interceptor into: $ENTRY_FILE"
            
            # Create a backup
            cp "$ENTRY_FILE" "${ENTRY_FILE}.backup"
            
            # Determine relative path to lib
            ENTRY_DIR=$(dirname "$ENTRY_FILE")
            if [ "$ENTRY_DIR" = "$SRC_DIR" ]; then
              IMPORT_PATH="./lib/apiInterceptor.js"
            else
              IMPORT_PATH="../lib/apiInterceptor.js"
            fi
            
            # Add import at the top of the file
            echo "import '$IMPORT_PATH';" | cat - "$ENTRY_FILE" > temp && mv temp "$ENTRY_FILE"
            
            echo "âœ… Interceptor injected"
            echo "ðŸ“„ Modified file content (first 10 lines):"
            head -10 "$ENTRY_FILE"
          fi

      - name: Update Vite config for GitHub Pages
        working-directory: ./frontend
        env:
          GITHUB_REPOSITORY: ${{ github.repository }}
        run: |
          echo "ðŸ“ Updating Vite config for GitHub Pages..."
          
          # Find the config file
          if [ -f "vite.config.js" ]; then
            CONFIG_FILE="vite.config.js"
          elif [ -f "vite.config.ts" ]; then
            CONFIG_FILE="vite.config.ts"
          else
            echo "âš ï¸ No vite.config found, creating one"
            cat > vite.config.js << 'VITE_EOF'
          import { defineConfig } from 'vite'
          import react from '@vitejs/plugin-react'
          import path from 'path'

          export default defineConfig({
            plugins: [react()],
            base: '/wealth-tracker/',
            build: {
              outDir: 'build',
            },
            resolve: {
              alias: {
                '@': path.resolve(__dirname, './src'),
              },
            },
          })
          VITE_EOF
            echo "âœ… Created new vite.config.js"
            exit 0
          fi
          
          echo "ðŸ“„ Original config:"
          cat "$CONFIG_FILE"
          
          # Backup original
          cp "$CONFIG_FILE" "${CONFIG_FILE}.backup"
          
          # Extract repo name from GITHUB_REPOSITORY
          REPO_NAME="${GITHUB_REPOSITORY#*/}"
          echo "ðŸ”§ Setting base path to: /$REPO_NAME/"
          
          # Check if base is already set and update it, or add it
          if grep -q "base:" "$CONFIG_FILE"; then
            # Replace existing base
            sed -i "s|base:.*|base: '/$REPO_NAME/',|g" "$CONFIG_FILE"
          else
            # Add base after defineConfig({
            sed -i "/defineConfig({/a\  base: '/$REPO_NAME/'," "$CONFIG_FILE"
          fi
          
          echo "âœ… Updated vite.config"
          echo "ðŸ“„ New config:"
          cat "$CONFIG_FILE"

      - name: Build
        working-directory: ./frontend
        env:
          GITHUB_REPOSITORY: ${{ github.repository }}
        run: |
          echo "ðŸ“¦ Building frontend..."
          npm run build
          
          echo "ðŸ“ Checking build output..."
          ls -la
          
          # Check for both dist and build directories
          if [ -d "dist" ]; then
            BUILD_DIR="dist"
            echo "âœ… Build directory 'dist' exists"
          elif [ -d "build" ]; then
            BUILD_DIR="build"
            echo "âœ… Build directory 'build' exists"
          else
            echo "âŒ No build directory found!"
            exit 1
          fi
          
          ls -la "$BUILD_DIR/"
          
          # Add a notice to the built index.html
          if [ -f "$BUILD_DIR/index.html" ]; then
            sed -i 's|<body>|<body><div style="background:#1e3a8a;color:white;padding:8px;text-align:center;font-size:14px;">ðŸ“Œ Demo Mode: Data stored in browser only â€¢ <a href="https://github.com/${{ github.repository }}" style="color:#60a5fa">View Source</a></div>|' "$BUILD_DIR/index.html"
            echo "âœ… Added demo banner"
          fi
          
          # Store the build directory name for the next step
          echo "BUILD_DIR=$BUILD_DIR" >> $GITHUB_ENV

      - name: Setup Pages
        uses: actions/configure-pages@v4

      - name: Upload artifact
        uses: actions/upload-pages-artifact@v3
        with:
          path: './frontend/${{ env.BUILD_DIR }}'

      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4

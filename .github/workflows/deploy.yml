name: Deploy Demo to GitHub Pages

on:
  push:
    branches: [ main ]
  workflow_dispatch:

permissions:
  contents: read
  pages: write
  id-token: write

concurrency:
  group: "pages"
  cancel-in-progress: false

jobs:
  deploy:
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json

      - name: Install dependencies
        working-directory: ./frontend
        run: npm ci

      - name: Create browser storage adapter
        working-directory: ./frontend
        run: |
          echo "ðŸ“ Current directory structure:"
          ls -la
          
          # Check if src exists, if not try to find where the source files are
          if [ -d "src" ]; then
            echo "âœ… src/ directory found"
            SRC_DIR="src"
          elif [ -d "app" ]; then
            echo "âœ… app/ directory found (Next.js style)"
            SRC_DIR="app"
          else
            echo "âš ï¸  Creating src/ directory"
            mkdir -p src
            SRC_DIR="src"
          fi
          
          # Create lib directory if it doesn't exist
          mkdir -p "$SRC_DIR/lib"
          
          # Create the browser storage module
          cat > "$SRC_DIR/lib/browserStorage.js" << 'STORAGE_EOF'
          // Auto-generated browser storage adapter for GitHub Pages demo
          
          const STORAGE_PREFIX = 'wealth_tracker_';
          
          const storage = {
            get: (key) => {
              try {
                const item = localStorage.getItem(STORAGE_PREFIX + key);
                return item ? JSON.parse(item) : null;
              } catch (e) {
                console.error('Storage get error:', e);
                return null;
              }
            },
            
            set: (key, value) => {
              try {
                localStorage.setItem(STORAGE_PREFIX + key, JSON.stringify(value));
                console.log('ðŸ’¾ Saved to storage:', key, value);
                return true;
              } catch (e) {
                console.error('Storage set error:', e);
                return false;
              }
            },
            
            remove: (key) => {
              try {
                localStorage.removeItem(STORAGE_PREFIX + key);
                return true;
              } catch (e) {
                console.error('Storage remove error:', e);
                return false;
              }
            },
            
            getAll: (prefix) => {
              const result = {};
              for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key && key.startsWith(STORAGE_PREFIX + prefix)) {
                  const shortKey = key.replace(STORAGE_PREFIX, '');
                  result[shortKey] = storage.get(shortKey.replace(prefix, ''));
                }
              }
              return result;
            }
          };
          
          // Initialize with sample data if empty
          const initSampleData = () => {
            if (!storage.get('initialized')) {
              console.log('ðŸŽ¬ Initializing sample data...');
              storage.set('initialized', true);
              storage.set('assets', [
                {
                  id: '1',
                  name: 'Savings Account',
                  type: 'Bank Account',
                  value: 25000,
                  currency: 'USD',
                  icon: 'piggy-bank',
                  createdAt: new Date().toISOString(),
                  updatedAt: new Date().toISOString()
                },
                {
                  id: '2',
                  name: 'Investment Portfolio',
                  type: 'Investments',
                  value: 50000,
                  currency: 'USD',
                  icon: 'trending-up',
                  createdAt: new Date().toISOString(),
                  updatedAt: new Date().toISOString()
                }
              ]);
              storage.set('settings', {
                currency: 'USD',
                theme: 'dark',
                locale: 'en-US'
              });
              console.log('âœ… Sample data initialized');
            }
          };
          
          export const mockAPI = {
            assets: {
              getAll: () => {
                const assets = storage.get('assets') || [];
                console.log('ðŸ“‹ Getting all assets:', assets.length);
                return Promise.resolve(assets);
              },
              getById: (id) => {
                const assets = storage.get('assets') || [];
                const asset = assets.find(a => a.id === id) || null;
                console.log('ðŸ” Getting asset by id:', id, asset);
                return Promise.resolve(asset);
              },
              create: (asset) => {
                console.log('âž• Creating asset:', asset);
                const assets = storage.get('assets') || [];
                const newAsset = {
                  ...asset,
                  id: Date.now().toString() + Math.random().toString(36).substr(2, 9),
                  createdAt: new Date().toISOString(),
                  updatedAt: new Date().toISOString()
                };
                assets.push(newAsset);
                storage.set('assets', assets);
                console.log('âœ… Asset created:', newAsset);
                return Promise.resolve(newAsset);
              },
              update: (id, updates) => {
                console.log('ðŸ“ Updating asset:', id, updates);
                const assets = storage.get('assets') || [];
                const index = assets.findIndex(a => a.id === id);
                if (index >= 0) {
                  assets[index] = { ...assets[index], ...updates, updatedAt: new Date().toISOString() };
                  storage.set('assets', assets);
                  console.log('âœ… Asset updated:', assets[index]);
                  return Promise.resolve(assets[index]);
                }
                console.warn('âš ï¸ Asset not found:', id);
                return Promise.resolve(null);
              },
              delete: (id) => {
                console.log('ðŸ—‘ï¸ Deleting asset:', id);
                let assets = storage.get('assets') || [];
                const initialLength = assets.length;
                assets = assets.filter(a => a.id !== id);
                storage.set('assets', assets);
                console.log('âœ… Asset deleted, remaining:', assets.length);
                return Promise.resolve({ success: true, deleted: initialLength !== assets.length });
              }
            },
            
            settings: {
              get: () => {
                const settings = storage.get('settings') || { currency: 'USD', theme: 'dark' };
                console.log('âš™ï¸ Getting settings:', settings);
                return Promise.resolve(settings);
              },
              update: (updates) => {
                console.log('âš™ï¸ Updating settings:', updates);
                const current = storage.get('settings') || {};
                const updated = { ...current, ...updates };
                storage.set('settings', updated);
                console.log('âœ… Settings updated:', updated);
                return Promise.resolve(updated);
              }
            },
            
            history: {
              getAll: () => {
                const assets = storage.get('assets') || [];
                const totalValue = assets.reduce((sum, a) => sum + (a.value || 0), 0);
                // Generate mock history data
                const history = [];
                for (let i = 30; i >= 0; i--) {
                  const date = new Date();
                  date.setDate(date.getDate() - i);
                  history.push({
                    date: date.toISOString(),
                    totalValue: totalValue * (0.9 + Math.random() * 0.2),
                    assetBreakdown: {}
                  });
                }
                console.log('ðŸ“Š Getting history:', history.length, 'entries');
                return Promise.resolve(history);
              }
            }
          };
          
          // Initialize on load
          if (typeof window !== 'undefined') {
            initSampleData();
          }
          
          export default mockAPI;
          STORAGE_EOF

      - name: Create API interceptor
        working-directory: ./frontend
        run: |
          # Use the same SRC_DIR we found earlier
          if [ -d "src" ]; then
            SRC_DIR="src"
          elif [ -d "app" ]; then
            SRC_DIR="app"
          else
            SRC_DIR="src"
          fi
          
          # Create an interceptor that replaces fetch calls
          cat > "$SRC_DIR/lib/apiInterceptor.js" << 'INTERCEPTOR_EOF'
          import mockAPI from './browserStorage.js';
          
          const originalFetch = window.fetch;
          
          // Helper to check if URL should be intercepted
          const shouldIntercept = (url) => {
            if (typeof url !== 'string') return false;
            // Intercept localhost:4000 calls and /api/ calls
            return url.includes('localhost:4000') || 
                   url.includes('/api/') ||
                   url.includes('/assets') ||
                   url.includes('/bankaccounts') ||
                   url.includes('/settings') ||
                   url.includes('/history');
          };
          
          // Helper to create proper fetch Response
          const createResponse = (data, status = 200) => {
            const responseData = data;
            return Promise.resolve({
              ok: status >= 200 && status < 300,
              status: status,
              statusText: status === 200 ? 'OK' : 'Error',
              headers: new Headers({ 'content-type': 'application/json' }),
              json: () => Promise.resolve(responseData),
              text: () => Promise.resolve(JSON.stringify(responseData)),
              blob: () => Promise.resolve(new Blob([JSON.stringify(responseData)])),
              arrayBuffer: () => Promise.resolve(new ArrayBuffer(0)),
              clone: function() { return createResponse(data, status); }
            });
          };
          
          // Intercept XMLHttpRequest for axios
          const originalXHROpen = XMLHttpRequest.prototype.open;
          const originalXHRSend = XMLHttpRequest.prototype.send;
          
          XMLHttpRequest.prototype.open = function(method, url, ...args) {
            this._method = method;
            this._url = url;
            return originalXHROpen.call(this, method, url, ...args);
          };
          
          XMLHttpRequest.prototype.send = function(body) {
            const url = this._url;
            const method = this._method;
            
            if (shouldIntercept(url)) {
              console.log('ðŸ”„ Intercepted XHR:', method, url);
              console.log('ðŸ“¦ Request body:', body);
              
              const handleRequest = async () => {
                let response;
                const parsedBody = body ? JSON.parse(body) : {};
                
                try {
                  // Assets endpoint (handles both /assets and /api/assets)
                  if (url.includes('/assets') || url.includes('/bankaccounts')) {
                    if (method === 'POST') {
                      response = await mockAPI.assets.create(parsedBody);
                      console.log('âœ… Asset created via XHR:', response);
                    } else if (method === 'PUT' || method === 'PATCH') {
                      const id = url.split('/').pop();
                      response = await mockAPI.assets.update(id, parsedBody);
                      console.log('âœ… Asset updated via XHR:', response);
                    } else if (method === 'DELETE') {
                      const id = url.split('/').pop();
                      response = await mockAPI.assets.delete(id);
                      console.log('âœ… Asset deleted via XHR:', id);
                    } else {
                      // GET - check if getting single asset or all
                      const urlParts = url.split('/');
                      const lastPart = urlParts[urlParts.length - 1];
                      if (lastPart && lastPart !== 'assets' && lastPart !== 'bankaccounts' && !lastPart.includes('?')) {
                        response = await mockAPI.assets.getById(lastPart);
                        console.log('âœ… Asset retrieved via XHR:', response);
                      } else {
                        response = await mockAPI.assets.getAll();
                        console.log('âœ… Assets retrieved via XHR:', response.length, 'assets');
                      }
                    }
                  } else if (url.includes('/settings')) {
                    if (method === 'PUT' || method === 'PATCH' || method === 'POST') {
                      response = await mockAPI.settings.update(parsedBody);
                      console.log('âœ… Settings updated via XHR:', response);
                    } else {
                      response = await mockAPI.settings.get();
                      console.log('âœ… Settings retrieved via XHR:', response);
                    }
                  } else if (url.includes('/history')) {
                    response = await mockAPI.history.getAll();
                    console.log('âœ… History retrieved via XHR:', response.length, 'entries');
                  } else {
                    response = { message: 'Endpoint not implemented' };
                    console.warn('âš ï¸ Unhandled endpoint:', url);
                  }
                  
                  // Simulate successful XHR response
                  Object.defineProperty(this, 'status', { value: 200, writable: false });
                  Object.defineProperty(this, 'statusText', { value: 'OK', writable: false });
                  Object.defineProperty(this, 'readyState', { value: 4, writable: false });
                  Object.defineProperty(this, 'responseText', { value: JSON.stringify(response), writable: false });
                  Object.defineProperty(this, 'response', { value: JSON.stringify(response), writable: false });
                  Object.defineProperty(this, 'responseType', { value: 'json', writable: false });
                  
                  const event = new Event('load');
                  this.dispatchEvent(event);
                  if (this.onload) this.onload(event);
                  if (this.onreadystatechange) this.onreadystatechange();
                } catch (error) {
                  console.error('âŒ XHR error:', error);
                  Object.defineProperty(this, 'status', { value: 500, writable: false });
                  Object.defineProperty(this, 'statusText', { value: 'Error', writable: false });
                  const errorEvent = new Event('error');
                  this.dispatchEvent(errorEvent);
                  if (this.onerror) this.onerror(errorEvent);
                }
              };
              
              setTimeout(() => handleRequest.call(this), 0);
              return;
            }
            
            return originalXHRSend.call(this, body);
          };
          
          // Also intercept fetch for completeness
          window.fetch = function(...args) {
            const url = args[0];
            const options = args[1] || {};
            
            if (shouldIntercept(url)) {
              console.log('ðŸ”„ Intercepted fetch:', options.method || 'GET', url);
              console.log('ðŸ“¦ Request body:', options.body);
              
              try {
                if (url.includes('/assets') || url.includes('/bankaccounts')) {
                  if (options.method === 'POST') {
                    const body = options.body ? JSON.parse(options.body) : {};
                    return mockAPI.assets.create(body).then(data => {
                      console.log('âœ… Asset created via fetch:', data);
                      return createResponse(data);
                    });
                  } else if (options.method === 'PUT' || options.method === 'PATCH') {
                    const id = url.split('/').pop();
                    const body = options.body ? JSON.parse(options.body) : {};
                    return mockAPI.assets.update(id, body).then(data => {
                      console.log('âœ… Asset updated via fetch:', data);
                      return createResponse(data);
                    });
                  } else if (options.method === 'DELETE') {
                    const id = url.split('/').pop();
                    return mockAPI.assets.delete(id).then(data => {
                      console.log('âœ… Asset deleted via fetch:', id);
                      return createResponse(data);
                    });
                  } else {
                    const urlParts = url.split('/');
                    const lastPart = urlParts[urlParts.length - 1];
                    if (lastPart && lastPart !== 'assets' && lastPart !== 'bankaccounts' && !lastPart.includes('?')) {
                      return mockAPI.assets.getById(lastPart).then(data => {
                        console.log('âœ… Asset retrieved via fetch:', data);
                        return createResponse(data);
                      });
                    }
                    return mockAPI.assets.getAll().then(data => {
                      console.log('âœ… Assets retrieved via fetch:', data.length, 'assets');
                      return createResponse(data);
                    });
                  }
                } else if (url.includes('/settings')) {
                  if (options.method === 'PUT' || options.method === 'PATCH' || options.method === 'POST') {
                    const body = options.body ? JSON.parse(options.body) : {};
                    return mockAPI.settings.update(body).then(data => {
                      console.log('âœ… Settings updated via fetch:', data);
                      return createResponse(data);
                    });
                  } else {
                    return mockAPI.settings.get().then(data => {
                      console.log('âœ… Settings retrieved via fetch:', data);
                      return createResponse(data);
                    });
                  }
                } else if (url.includes('/history')) {
                  return mockAPI.history.getAll().then(data => {
                    console.log('âœ… History retrieved via fetch:', data.length, 'entries');
                    return createResponse(data);
                  });
                }
                
                console.warn('âš ï¸ Unhandled endpoint via fetch:', url);
                return createResponse({ message: 'Endpoint not implemented' }, 404);
              } catch (error) {
                console.error('âŒ Fetch interceptor error:', error);
                return createResponse({ error: error.message }, 500);
              }
            }
            
            // Pass through non-API calls
            return originalFetch.apply(this, args);
          };
          
          console.log('âœ… Browser storage API interceptor loaded (fetch + XHR)');
          console.log('ðŸ“¡ Intercepting: localhost:4000, /api/, /assets, /bankaccounts, /settings, /history');
          INTERCEPTOR_EOF

      - name: Inject interceptor into entry point
        working-directory: ./frontend
        run: |
          echo "ðŸ” Looking for entry file..."
          
          # Determine source directory
          if [ -d "src" ]; then
            SRC_DIR="src"
          elif [ -d "app" ]; then
            SRC_DIR="app"
          else
            SRC_DIR="."
          fi
          
          echo "ðŸ“ Using source directory: $SRC_DIR"
          ls -la "$SRC_DIR/"
          
          # Find the main entry file
          ENTRY_FILE=$(find "$SRC_DIR" -maxdepth 1 \( -name "main.*" -o -name "index.*" -o -name "App.*" \) | head -1)
          
          if [ -z "$ENTRY_FILE" ]; then
            echo "âš ï¸  Could not find entry file, checking subdirectories..."
            ENTRY_FILE=$(find "$SRC_DIR" -maxdepth 2 \( -name "main.*" -o -name "index.*" \) | head -1)
          fi
          
          if [ -z "$ENTRY_FILE" ]; then
            echo "âŒ Could not find entry file. Available files:"
            find "$SRC_DIR" -type f -name "*.jsx" -o -name "*.tsx" -o -name "*.js" -o -name "*.ts"
            echo "âš ï¸  Skipping interceptor injection - will rely on manual API replacement"
          else
            echo "ðŸ“ Injecting interceptor into: $ENTRY_FILE"
            
            # Create a backup
            cp "$ENTRY_FILE" "${ENTRY_FILE}.backup"
            
            # Determine relative path to lib
            ENTRY_DIR=$(dirname "$ENTRY_FILE")
            if [ "$ENTRY_DIR" = "$SRC_DIR" ]; then
              IMPORT_PATH="./lib/apiInterceptor.js"
            else
              IMPORT_PATH="../lib/apiInterceptor.js"
            fi
            
            # Add import at the top of the file
            echo "import '$IMPORT_PATH';" | cat - "$ENTRY_FILE" > temp && mv temp "$ENTRY_FILE"
            
            echo "âœ… Interceptor injected"
            echo "ðŸ“„ Modified file content (first 10 lines):"
            head -10 "$ENTRY_FILE"
          fi

      - name: Update Vite config for GitHub Pages
        working-directory: ./frontend
        env:
          GITHUB_REPOSITORY: ${{ github.repository }}
        run: |
          echo "ðŸ“ Updating Vite config for GitHub Pages..."
          
          # Find the config file
          if [ -f "vite.config.js" ]; then
            CONFIG_FILE="vite.config.js"
          elif [ -f "vite.config.ts" ]; then
            CONFIG_FILE="vite.config.ts"
          else
            echo "âš ï¸ No vite.config found, creating one"
            cat > vite.config.js << 'VITE_EOF'
          import { defineConfig } from 'vite'
          import react from '@vitejs/plugin-react'
          import path from 'path'

          export default defineConfig({
            plugins: [react()],
            base: '/wealth-tracker/',
            build: {
              outDir: 'build',
            },
            resolve: {
              alias: {
                '@': path.resolve(__dirname, './src'),
              },
            },
          })
          VITE_EOF
            echo "âœ… Created new vite.config.js"
            exit 0
          fi
          
          echo "ðŸ“„ Original config:"
          cat "$CONFIG_FILE"
          
          # Backup original
          cp "$CONFIG_FILE" "${CONFIG_FILE}.backup"
          
          # Extract repo name from GITHUB_REPOSITORY
          REPO_NAME="${GITHUB_REPOSITORY#*/}"
          echo "ðŸ”§ Setting base path to: /$REPO_NAME/"
          
          # Check if base is already set and update it, or add it
          if grep -q "base:" "$CONFIG_FILE"; then
            # Replace existing base
            sed -i "s|base:.*|base: '/$REPO_NAME/',|g" "$CONFIG_FILE"
          else
            # Add base after defineConfig({
            sed -i "/defineConfig({/a\  base: '/$REPO_NAME/'," "$CONFIG_FILE"
          fi
          
          echo "âœ… Updated vite.config"
          echo "ðŸ“„ New config:"
          cat "$CONFIG_FILE"

      - name: Build
        working-directory: ./frontend
        env:
          GITHUB_REPOSITORY: ${{ github.repository }}
        run: |
          echo "ðŸ“¦ Building frontend..."
          npm run build
          
          echo "ðŸ“ Checking build output..."
          ls -la
          
          # Check for both dist and build directories
          if [ -d "dist" ]; then
            BUILD_DIR="dist"
            echo "âœ… Build directory 'dist' exists"
          elif [ -d "build" ]; then
            BUILD_DIR="build"
            echo "âœ… Build directory 'build' exists"
          else
            echo "âŒ No build directory found!"
            exit 1
          fi
          
          ls -la "$BUILD_DIR/"
          
          # Add a notice to the built index.html
          if [ -f "$BUILD_DIR/index.html" ]; then
            sed -i 's|<body>|<body><div style="background:#1e3a8a;color:white;padding:8px;text-align:center;font-size:14px;">ðŸ“Œ Demo Mode: Data stored in browser only â€¢ <a href="https://github.com/${{ github.repository }}" style="color:#60a5fa">View Source</a></div>|' "$BUILD_DIR/index.html"
            echo "âœ… Added demo banner"
          fi
          
          # Store the build directory name for the next step
          echo "BUILD_DIR=$BUILD_DIR" >> $GITHUB_ENV

      - name: Setup Pages
        uses: actions/configure-pages@v4

      - name: Upload artifact
        uses: actions/upload-pages-artifact@v3
        with:
          path: './frontend/${{ env.BUILD_DIR }}'

      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4
